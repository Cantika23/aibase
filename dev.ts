#!/usr/bin/env bun
/**
 * Development script to run backend and frontend concurrently
 */

import { $, within, ProcessPromise } from 'bun'
import { spawn } from 'child_process'
import { existsSync, readFileSync, writeFileSync } from 'fs'
import { join } from 'path'

const SCRIPT_DIR = process.cwd()
const PORTS_FILE = join(SCRIPT_DIR, '.dev-ports')
const ENV_FILE = join(SCRIPT_DIR, '.env')

const DEFAULT_BACKEND_PORT = 5040
const DEFAULT_FRONTEND_PORT = 5173
const PORT_RANGE_START = 5041
const PORT_RANGE_END = 5100

// ANSI colors
const colors = {
  red: '\x1b[0;31m',
  green: '\x1b[0;32m',
  yellow: '\x1b[1;33m',
  blue: '\x1b[0;34m',
  reset: '\x1b[0m',
}

function log(message: string, color: keyof typeof colors = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`)
}

function error(message: string): never {
  log(`ERROR: ${message}`, 'red')
  process.exit(1)
}

function warn(message: string) {
  log(`WARNING: ${message}`, 'yellow')
}

function success(message: string) {
  log(message, 'green')
}

/**
 * Check if a port is in use by attempting to connect to it
 */
async function isPortInUse(port: number): Promise<boolean> {
  // Try to connect to the port
  const conn = Bun.connect({
    hostname: 'localhost',
    port,
    socket: {
      data(socket, data) {},
      open(socket) {
        socket.end()
      },
      close() {},
    },
    timeout: 100,
  })

  // If connection succeeds, port is in use
  try {
    await conn
    return true
  } catch {
    // Connection failed, port is available
    return false
  }
}

/**
 * Find an available port in the given range
 */
async function findAvailablePort(start: number, end: number): Promise<number> {
  for (let port = start; port <= end; port++) {
    if (!(await isPortInUse(port))) {
      return port
    }
  }
  error(`Could not find available port in range ${start}-${end}`)
}

/**
 * Load saved ports from .dev-ports file
 */
interface PortsConfig {
  BACKEND_PORT?: number
}

function loadSavedPorts(): PortsConfig {
  if (!existsSync(PORTS_FILE)) {
    return {}
  }

  try {
    const content = readFileSync(PORTS_FILE, 'utf-8')
    const config: PortsConfig = {}
    for (const line of content.split('\n')) {
      const match = line.match(/^BACKEND_PORT=(\d+)$/)
      if (match) {
        config.BACKEND_PORT = parseInt(match[1], 10)
      }
    }
    return config
  } catch {
    return {}
  }
}

/**
 * Save port configuration to .dev-ports file
 */
function savePorts(backendPort: number) {
  const content = `# Development ports - auto-generated by dev.ts
# To reset ports, delete this file and run dev.ts again
BACKEND_PORT=${backendPort}
`
  writeFileSync(PORTS_FILE, content)
  success(`Port configuration saved to ${PORTS_FILE}`)
}

/**
 * Get information about what's using a port
 */
async function getPortInfo(port: number): Promise<string | null> {
  // Method 1: Try lsof
  try {
    const proc = Bun.spawn(['lsof', '-i', `:${port}`, '-t', '-P', '-n'], {
      stdout: 'pipe',
      stderr: 'ignore',
    })

    const output = await new Response(proc.stdout).text()
    await proc.exited

    if (output.trim()) {
      return await getProcessInfo(output.trim())
    }
  } catch {
    // lsof not available, try other methods
  }

  // Method 2: Try fuser (commonly available)
  try {
    const proc = Bun.spawn(['fuser', `${port}/tcp`, '-n', 'tcp'], {
      stdout: 'pipe',
      stderr: 'ignore',
    })

    const output = await new Response(proc.stdout).text()
    await proc.exited

    // fuser returns: <port>/tcp: <pid>
    const match = output.match(/:(\d+)/)
    if (match) {
      return await getProcessInfo(match[1])
    }
  } catch {
    // fuser not available
  }

  // Method 3: Try ss on Linux
  try {
    const proc = Bun.spawn(['ss', '-tlnp', `sport = :${port}`], {
      stdout: 'pipe',
      stderr: 'ignore',
    })

    const output = await new Response(proc.stdout).text()
    await proc.exited

    // ss output format: ... pid=<pid>,...  or ... users:(("cmd",pid=<pid>,...) ...
    const pidMatch = output.match(/pid=(\d+)|"(\w+)",pid=(\d+)/)
    if (pidMatch) {
      const pid = pidMatch[1] || pidMatch[3]
      const cmd = pidMatch[2] || ''
      if (pid) {
        const procInfo = cmd ? `PID ${pid} (${cmd})` : `PID ${pid}`
        // Try to get user
        try {
          const userProc = Bun.spawn(['ps', '-p', pid, '-o', 'user='], {
            stdout: 'pipe',
            stderr: 'ignore',
          })
          const user = (await new Response(userProc.stdout).text()).trim()
          await userProc.exited
          return `${procInfo} by ${user}`
        } catch {
          return procInfo
        }
      }
    }
  } catch {
    // ss not available
  }

  return null
}

/**
 * Get process info from PID(s)
 */
async function getProcessInfo(pidsStr: string): Promise<string> {
  const pids = pidsStr.trim().split('\n').filter(Boolean)
  const infos: string[] = []

  for (const pid of pids) {
    try {
      // Try to read from /proc on Linux
      const cmdlinePath = `/proc/${pid}/cmdline`
      const statusPath = `/proc/${pid}/status`

      let cmd = ''
      let user = ''

      try {
        const cmdlineFile = Bun.file(cmdlinePath)
        if (cmdlineFile.exists) {
          const cmdline = await cmdlineFile.text()
          // cmdline has null-byte separated args, take first
          const args = cmdline.split('\0').filter(Boolean)
          cmd = args[0]?.split('/').pop() || 'unknown'
        }
      } catch {
        // /proc not available (non-Linux), use ps
      }

      try {
        const statusFile = Bun.file(statusPath)
        if (statusFile.exists) {
          const status = await statusFile.text()
          const uidMatch = status.match(/Uid:\s*(\d+)/)
          if (uidMatch) {
            // Try to get username from UID
            try {
              const userProc = Bun.spawn(['getent', 'passwd', uidMatch[1]], {
                stdout: 'pipe',
                stderr: 'ignore',
              })
              const passwdEntry = (await new Response(userProc.stdout).text()).trim()
              await userProc.exited
              user = passwdEntry.split(':')[0] || uidMatch[1]
            } catch {
              user = uidMatch[1]
            }
          }
        }
      } catch {
        // /proc not available
      }

      // Fallback to ps if we didn't get info from /proc
      if (!cmd || !user) {
        const psProc = Bun.spawn(['ps', '-p', pid, '-o', 'comm,user='], {
          stdout: 'pipe',
          stderr: 'ignore',
        })
        const psOutput = (await new Response(psProc.stdout).text()).trim()
        await psProc.exited
        const parts = psOutput.split(/\s+/)
        if (parts.length >= 2) {
          cmd = cmd || parts[0]
          user = user || parts[1]
        }
      }

      infos.push(`PID ${pid}${cmd ? ` (${cmd})` : ''}${user ? ` by ${user}` : ''}`)
    } catch {
      infos.push(`PID ${pid}`)
    }
  }

  return infos.join(', ')
}

/**
 * Check and display port usage before starting services
 */
async function checkPorts(): Promise<void> {
  log('=== Checking Ports ===', 'blue')

  const ports = [
    { name: 'Backend (default)', port: DEFAULT_BACKEND_PORT },
    { name: 'Frontend (default)', port: DEFAULT_FRONTEND_PORT },
  ]

  let foundInUse = false

  for (const { name, port } of ports) {
    if (await isPortInUse(port)) {
      foundInUse = true
      const info = await getPortInfo(port)
      if (info) {
        log(`  ${name} (${port}): IN USE by ${info}`, 'yellow')
      } else {
        log(`  ${name} (${port}): IN USE`, 'yellow')
      }
    } else {
      log(`  ${name} (${port}): available`, 'green')
    }
  }

  if (foundInUse) {
    log('', 'reset')
    warn('Some ports are already in use. Will find alternatives if needed.')
  }

  log('', 'reset')
}

/**
 * Initialize and validate port configuration
 */
async function initializePorts(): Promise<number> {
  log('=== Port Allocation ===', 'blue')

  const saved = loadSavedPorts()
  let backendPort: number

  if (saved.BACKEND_PORT) {
    if (await isPortInUse(saved.BACKEND_PORT)) {
      const info = await getPortInfo(saved.BACKEND_PORT)
      warn(`Saved backend port ${saved.BACKEND_PORT} is in use${info ? ` by ${info}` : ''}, finding alternative...`)
      backendPort = await findAvailablePort(PORT_RANGE_START, PORT_RANGE_END)
      success(`Found available backend port: ${backendPort}`)
    } else {
      success(`Using saved backend port: ${saved.BACKEND_PORT}`)
      backendPort = saved.BACKEND_PORT
    }
  } else {
    if (await isPortInUse(DEFAULT_BACKEND_PORT)) {
      const info = await getPortInfo(DEFAULT_BACKEND_PORT)
      warn(`Default backend port ${DEFAULT_BACKEND_PORT} is in use${info ? ` by ${info}` : ''}`)
      backendPort = await findAvailablePort(PORT_RANGE_START, PORT_RANGE_END)
      success(`Found available backend port: ${backendPort}`)
    } else {
      backendPort = DEFAULT_BACKEND_PORT
      success(`Using default backend port: ${backendPort}`)
    }
  }

  success(`Using frontend port: ${DEFAULT_FRONTEND_PORT} (Vite may auto-adjust if in use)`)
  savePorts(backendPort)

  return backendPort
}

/**
 * Load and validate environment variables
 */
function loadEnv() {
  if (!existsSync(ENV_FILE)) {
    error('.env file not found. Please copy .env.example to .env and configure it.')
  }

  // Bun automatically loads .env files, but let's validate required vars
  const envFile = readFileSync(ENV_FILE, 'utf-8')
  const env: Record<string, string> = {}

  for (const line of envFile.split('\n')) {
    const match = line.match(/^([^=]+)=(.*)$/)
    if (match && !line.trim().startsWith('#')) {
      env[match[1]] = match[2]
    }
  }

  const missing: string[] = []
  if (!env.OPENAI_API_KEY || env.OPENAI_API_KEY === 'your-zai-api-key' || env.OPENAI_API_KEY === 'your-openrouter-api-key') {
    missing.push('OPENAI_API_KEY')
  }
  if (!env.OPENAI_BASE_URL) missing.push('OPENAI_BASE_URL')
  if (!env.OPENAI_MODEL) missing.push('OPENAI_MODEL')

  if (missing.length > 0) {
    error(`Missing or invalid required environment variables:
  - ${missing.join('\n  - ')}

Please configure these variables in your .env file.`)
  }

  success('Environment variables validated')
}

/**
 * Check and install dependencies if needed
 */
async function checkDependencies(dir: string, name: string) {
  log(`Checking ${name} dependencies...`)

  const nodeModules = join(dir, 'node_modules')
  const packageJson = join(dir, 'package.json')

  let needsInstall = false

  if (!existsSync(nodeModules)) {
    warn(`${name} node_modules not found. Installing...`)
    needsInstall = true
  } else if (existsSync(packageJson)) {
    // Check if package.json is newer than node_modules
    const pkgStat = await Bun.file(packageJson).stat()
    const nmStat = await Bun.file(nodeModules).stat()
    if (pkgStat.mtime > nmStat.mtime) {
      warn(`${name} package.json is newer than node_modules. Updating dependencies...`)
      needsInstall = true
    }
  }

  if (needsInstall) {
    const proc = Bun.spawn(['bun', 'install'], {
      cwd: dir,
      stdout: 'inherit',
      stderr: 'inherit',
    })
    const exitCode = await proc.exited
    if (exitCode !== 0) {
      error(`Failed to install ${name} dependencies`)
    }
    success(`${name} dependencies installed`)
  } else {
    success(`${name} dependencies OK`)
  }
}

/**
 * Start AIMEOW service if enabled
 */
async function startAimeow(backendPort: number): Promise<ProcessPromise | null> {
  const aimeowEnabled = process.env.AIMEOW === 'true'

  if (!aimeowEnabled) {
    return null
  }

  const aimeowDir = join(SCRIPT_DIR, 'bins', 'aimeow')
  const aimeowBinary = process.platform === 'darwin'
    ? join(aimeowDir, 'aimeow.macos')
    : join(aimeowDir, 'aimeow.linux')

  if (!existsSync(aimeowBinary)) {
    warn('AIMEOW binary not found, skipping WhatsApp service')
    return null
  }

  // Check if binary needs to be rebuilt
  const mainGo = join(aimeowDir, 'main.go')
  const needsBuild = !existsSync(aimeowBinary) ||
    (existsSync(mainGo) && (await Bun.file(mainGo).stat()).mtime > (await Bun.file(aimeowBinary).stat()).mtime)

  if (needsBuild) {
    log('Building AIMEOW...', 'blue')
    const buildProc = Bun.spawn(['go', 'build', '-ldflags=-s -w', `-o=${aimeowBinary}`, '.'], {
      cwd: aimeowDir,
      env: {
        ...process.env,
        CGO_ENABLED: '1',
      },
      stdout: 'inherit',
      stderr: 'inherit',
    })
    const exitCode = await buildProc.exited
    if (exitCode !== 0) {
      warn('Failed to build AIMEOW, skipping WhatsApp service')
      return null
    }
  }

  // Create AIMEOW data directory
  const aimeowDataDir = join(SCRIPT_DIR, 'data', 'services', 'whatsapp')
  await $`mkdir -p ${join(aimeowDataDir, 'files')}`

  // Start AIMEOW
  log('Starting AIMEOW service...', 'blue')
  const proc = Bun.spawn([aimeowBinary], {
    cwd: aimeowDataDir,
    env: {
      ...process.env,
      PORT: '7031',
      BASE_URL: 'http://localhost:7031',
      CALLBACK_URL: `http://localhost:${backendPort}/api/whatsapp/webhook`,
      DATA_DIR: '.',
      AIMEOW_LOG_CONFIG: join(SCRIPT_DIR, 'logging.json'),
    },
    stdout: 'inherit',
    stderr: 'inherit',
  })

  return proc
}

/**
 * Wait for a port to start listening
 */
async function waitForPort(port: number, maxWait = 5000): Promise<boolean> {
  const start = Date.now()
  while (Date.now() - start < maxWait) {
    if (await isPortInUse(port)) {
      return true
    }
    await new Promise(resolve => setTimeout(resolve, 100))
  }
  return false
}

/**
 * Start backend with port retry logic
 */
async function startBackend(backendPort: number): Promise<{ proc: typeof Bun.spawn, port: number }> {
  log('Waiting for backend to start on port ' + backendPort + '...')

  const proc = Bun.spawn(
    ['bun', '--watch', '--env-file=.env', 'run', 'backend/src/server/index.ts'],
    {
      cwd: SCRIPT_DIR,
      env: {
        ...process.env,
        BACKEND_PORT: backendPort.toString(),
      },
      stdout: 'inherit',
      stderr: 'inherit',
    }
  )

  // Wait for backend to start
  if (!(await waitForPort(backendPort, 5000))) {
    log('', 'reset')
    warn(`Backend failed to start on port ${backendPort} (port is in use)`)
    warn('Attempting to find an alternative port...')

    // Kill the failed backend process
    proc.kill()
    await proc.exited

    // Find an available port
    const newPort = await findAvailablePort(backendPort + 1, PORT_RANGE_END)
    success(`Retrying with port ${newPort}...`)

    // Update ports file
    savePorts(newPort)

    // Restart with new port
    const newProc = Bun.spawn(
      ['bun', '--watch', '--env-file=.env', 'run', 'backend/src/server/index.ts'],
      {
        cwd: SCRIPT_DIR,
        env: {
          ...process.env,
          BACKEND_PORT: newPort.toString(),
        },
        stdout: 'inherit',
        stderr: 'inherit',
      }
    )

    // Wait and verify
    if (!(await waitForPort(newPort, 5000))) {
      error(`Backend failed to start on port ${newPort} as well.
Please check what's using these ports and try again.`)
    }

    success(`Backend started successfully on port ${newPort}`)
    return { proc: newProc, port: newPort }
  }

  success(`Backend is listening on port ${backendPort}`)
  return { proc, port: backendPort }
}

/**
 * Main execution
 */
async function main() {
  const processes: (ReturnType<typeof Bun.spawn> | ProcessPromise)[] = []

  // Setup cleanup handler
  const cleanup = async () => {
    log('', 'reset')
    log('Shutting down services...', 'yellow')

    for (const proc of processes) {
      proc.kill()
      await proc.exited
    }

    success('All services stopped')
    process.exit(0)
  }

  process.on('SIGINT', cleanup)
  process.on('SIGTERM', cleanup)

  // Load and validate environment
  loadEnv()

  // Check dependencies
  await checkDependencies(join(SCRIPT_DIR, 'backend'), 'Backend')
  await checkDependencies(join(SCRIPT_DIR, 'frontend'), 'Frontend')

  // Check current port usage
  await checkPorts()

  // Initialize ports
  const backendPort = await initializePorts()
  log('')

  // Start AIMEOW if enabled
  const aimeowProc = await startAimeow(backendPort)
  if (aimeowProc) {
    processes.push(aimeowProc)
  }

  // Start services
  log('=== Starting Services ===', 'blue')
  success(`Backend will run on port ${backendPort}`)
  success(`Frontend will run on port ${DEFAULT_FRONTEND_PORT}`)
  log('')

  // Start backend with hot-reload
  const { proc: backendProc, port: finalBackendPort } = await startBackend(backendPort)
  processes.push(backendProc)

  // Start frontend
  const frontendProc = Bun.spawn(['bun', 'run', 'dev'], {
    cwd: join(SCRIPT_DIR, 'frontend'),
    env: {
      ...process.env,
      PORT: DEFAULT_FRONTEND_PORT.toString(),
      BACKEND_PORT: finalBackendPort.toString(),
    },
    stdout: 'inherit',
    stderr: 'inherit',
  })
  processes.push(frontendProc)

  success('âœ“ All services started')
  log('')
  log(`Backend:  http://localhost:${finalBackendPort}`, 'blue')
  log(`Frontend: http://localhost:${DEFAULT_FRONTEND_PORT}`, 'blue')
  log('')
  log('Press Ctrl+C to stop all services')
  log('')

  // Wait for all processes
  await Promise.all(processes.map(p => p.exited))
}

main().catch(err => {
  error(err.message)
})
