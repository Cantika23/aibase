#!/usr/bin/env bun
/**
 * Development script to run backend and frontend concurrently
 */

import { $, within, ProcessPromise } from 'bun'
import { spawn } from 'child_process'
import { existsSync, readFileSync, writeFileSync } from 'fs'
import { join } from 'path'

const SCRIPT_DIR = process.cwd()
const PORTS_FILE = join(SCRIPT_DIR, '.dev-ports')
const ENV_FILE = join(SCRIPT_DIR, '.env')

const DEFAULT_BACKEND_PORT = 5040
const DEFAULT_FRONTEND_PORT = 5173
const PORT_RANGE_START = 5041
const PORT_RANGE_END = 5100

// ANSI colors matching backend logging
const colors = {
  black: '\x1b[0;30m',
  red: '\x1b[0;31m',
  green: '\x1b[0;32m',
  yellow: '\x1b[0;33m',
  blue: '\x1b[0;34m',
  magenta: '\x1b[0;35m',
  cyan: '\x1b[0;36m',
  white: '\x1b[0;37m',
  brightBlack: '\x1b[1;30m',
  brightRed: '\x1b[1;31m',
  brightGreen: '\x1b[1;32m',
  brightYellow: '\x1b[1;33m',
  brightBlue: '\x1b[1;34m',
  brightMagenta: '\x1b[1;35m',
  brightCyan: '\x1b[1;36m',
  brightWhite: '\x1b[1;37m',
  reset: '\x1b[0m',
}

/**
 * Format timestamp to match backend logging (HH:MM:SS.mmm)
 */
function formatTimestamp(): string {
  const now = new Date()
  const hours = String(now.getHours()).padStart(2, '0')
  const minutes = String(now.getMinutes()).padStart(2, '0')
  const seconds = String(now.getSeconds()).padStart(2, '0')
  const millis = String(now.getMilliseconds()).padStart(3, '0')
  return `${hours}:${minutes}:${seconds}.${millis}`
}

/**
 * Log a message following the backend logging format
 * Format: HH:MM:SS.mmm [DEV] [Category] Message
 */
function log(category: string, message: string, categoryColor = colors.cyan) {
  const time = formatTimestamp()
  const reset = colors.reset
  console.log(`${time} ${colors.brightMagenta}[DEV]${reset} ${categoryColor}[${category}]${reset} ${message}`)
}

function error(message: string): never {
  log('Error', message, colors.red)
  process.exit(1)
}

function warn(message: string) {
  log('Warning', message, colors.yellow)
}

/**
 * Check if a port is in use by attempting to connect to it
 */
async function isPortInUse(port: number): Promise<boolean> {
  // Try to connect to the port
  const conn = Bun.connect({
    hostname: 'localhost',
    port,
    socket: {
      data(socket, data) {},
      open(socket) {
        socket.end()
      },
      close() {},
    },
    timeout: 100,
  })

  // If connection succeeds, port is in use
  try {
    await conn
    return true
  } catch {
    // Connection failed, port is available
    return false
  }
}

/**
 * Find an available port in the given range
 */
async function findAvailablePort(start: number, end: number): Promise<number> {
  for (let port = start; port <= end; port++) {
    if (!(await isPortInUse(port))) {
      return port
    }
  }
  error(`Could not find available port in range ${start}-${end}`)
}

/**
 * Load saved ports from .dev-ports file
 */
interface PortsConfig {
  BACKEND_PORT?: number
  FRONTEND_PORT?: number
}

function loadSavedPorts(): PortsConfig {
  if (!existsSync(PORTS_FILE)) {
    return {}
  }

  try {
    const content = readFileSync(PORTS_FILE, 'utf-8')
    const config: PortsConfig = {}
    for (const line of content.split('\n')) {
      const backendMatch = line.match(/^BACKEND_PORT=(\d+)$/)
      const frontendMatch = line.match(/^FRONTEND_PORT=(\d+)$/)
      if (backendMatch) {
        config.BACKEND_PORT = parseInt(backendMatch[1], 10)
      } else if (frontendMatch) {
        config.FRONTEND_PORT = parseInt(frontendMatch[1], 10)
      }
    }
    return config
  } catch {
    return {}
  }
}

/**
 * Save port configuration to .dev-ports file
 */
function savePorts(backendPort: number, frontendPort: number) {
  const content = `# Development ports - auto-generated by dev.ts
# To reset ports, delete this file and run dev.ts again
BACKEND_PORT=${backendPort}
FRONTEND_PORT=${frontendPort}
`
  writeFileSync(PORTS_FILE, content)
}

/**
 * Get information about what's using a port
 */
async function getPortInfo(port: number): Promise<string | null> {
  // Method 1: Try lsof (most reliable, installed in Dockerfiles)
  try {
    const proc = Bun.spawn(['lsof', '-i', `:${port}`, '-t', '-P', '-n'], {
      stdout: 'pipe',
      stderr: 'ignore',
    })

    const output = await new Response(proc.stdout).text()
    await proc.exited

    if (output.trim()) {
      return await getProcessInfo(output.trim())
    }
  } catch {
    // lsof not available, try fallback methods
  }

  // Method 2: Try fuser (commonly available)
  try {
    const proc = Bun.spawn(['fuser', `${port}/tcp`, '-n', 'tcp'], {
      stdout: 'pipe',
      stderr: 'ignore',
    })

    const output = await new Response(proc.stdout).text()
    await proc.exited

    // fuser returns: <port>/tcp: <pid>
    const match = output.match(/:(\d+)/)
    if (match) {
      return await getProcessInfo(match[1])
    }
  } catch {
    // fuser not available
  }

  return null
}

/**
 * Get process info from PID(s)
 */
async function getProcessInfo(pidsStr: string): Promise<string> {
  const pids = pidsStr.trim().split('\n').filter(Boolean)
  const infos: string[] = []

  for (const pid of pids) {
    try {
      // Try to read from /proc on Linux
      const cmdlinePath = `/proc/${pid}/cmdline`
      const statusPath = `/proc/${pid}/status`

      let cmd = ''
      let user = ''

      try {
        const cmdlineFile = Bun.file(cmdlinePath)
        if (cmdlineFile.exists) {
          const cmdline = await cmdlineFile.text()
          // cmdline has null-byte separated args, take first
          const args = cmdline.split('\0').filter(Boolean)
          cmd = args[0]?.split('/').pop() || 'unknown'
        }
      } catch {
        // /proc not available (non-Linux), use ps
      }

      try {
        const statusFile = Bun.file(statusPath)
        if (statusFile.exists) {
          const status = await statusFile.text()
          const uidMatch = status.match(/Uid:\s*(\d+)/)
          if (uidMatch) {
            // Try to get username from UID
            try {
              const userProc = Bun.spawn(['getent', 'passwd', uidMatch[1]], {
                stdout: 'pipe',
                stderr: 'ignore',
              })
              const passwdEntry = (await new Response(userProc.stdout).text()).trim()
              await userProc.exited
              user = passwdEntry.split(':')[0] || uidMatch[1]
            } catch {
              user = uidMatch[1]
            }
          }
        }
      } catch {
        // /proc not available
      }

      // Fallback to ps if we didn't get info from /proc
      if (!cmd || !user) {
        const psProc = Bun.spawn(['ps', '-p', pid, '-o', 'comm,user='], {
          stdout: 'pipe',
          stderr: 'ignore',
        })
        const psOutput = (await new Response(psProc.stdout).text()).trim()
        await psProc.exited
        const parts = psOutput.split(/\s+/)
        if (parts.length >= 2) {
          cmd = cmd || parts[0]
          user = user || parts[1]
        }
      }

      infos.push(`PID ${pid}${cmd ? ` (${cmd})` : ''}${user ? ` by ${user}` : ''}`)
    } catch {
      infos.push(`PID ${pid}`)
    }
  }

  return infos.join(', ')
}

/**
 * Check and display port usage before starting services
 */
async function checkPorts(): Promise<void> {
  console.log('')  // blank line for separation
  log('Ports', 'Checking default ports...')
  console.log('')

  const ports = [
    { name: 'Backend (default)', port: DEFAULT_BACKEND_PORT },
    { name: 'Frontend (default)', port: DEFAULT_FRONTEND_PORT },
  ]

  for (const { name, port } of ports) {
    if (await isPortInUse(port)) {
      const info = await getPortInfo(port)
      if (info) {
        console.log(`  ${name} (${port}): in use by ${info}`)
      } else {
        console.log(`  ${name} (${port}): in use`)
      }
    } else {
      console.log(`  ${name} (${port}): available`)
    }
  }

  console.log('')
}

/**
 * Initialize and validate port configuration
 */
async function initializePorts(): Promise<{ backend: number; frontend: number }> {
  log('Ports', 'Allocating ports...')

  const saved = loadSavedPorts()
  let backendPort: number
  let frontendPort: number

  // Allocate backend port
  if (saved.BACKEND_PORT) {
    if (await isPortInUse(saved.BACKEND_PORT)) {
      const info = await getPortInfo(saved.BACKEND_PORT)
      console.log(`  Backend port ${saved.BACKEND_PORT} in use${info ? ` (${info})` : ''}, using alternative...`)
      backendPort = await findAvailablePort(PORT_RANGE_START, PORT_RANGE_END)
    } else {
      backendPort = saved.BACKEND_PORT
    }
  } else {
    if (await isPortInUse(DEFAULT_BACKEND_PORT)) {
      const info = await getPortInfo(DEFAULT_BACKEND_PORT)
      console.log(`  Backend port ${DEFAULT_BACKEND_PORT} in use${info ? ` (${info})` : ''}, using alternative...`)
      backendPort = await findAvailablePort(PORT_RANGE_START, PORT_RANGE_END)
    } else {
      backendPort = DEFAULT_BACKEND_PORT
    }
  }

  // Allocate frontend port
  if (saved.FRONTEND_PORT) {
    if (await isPortInUse(saved.FRONTEND_PORT)) {
      const info = await getPortInfo(saved.FRONTEND_PORT)
      console.log(`  Frontend port ${saved.FRONTEND_PORT} in use${info ? ` (${info})` : ''}, using alternative...`)
      frontendPort = await findAvailablePort(DEFAULT_FRONTEND_PORT + 1, DEFAULT_FRONTEND_PORT + 100)
    } else {
      frontendPort = saved.FRONTEND_PORT
    }
  } else {
    if (await isPortInUse(DEFAULT_FRONTEND_PORT)) {
      const info = await getPortInfo(DEFAULT_FRONTEND_PORT)
      console.log(`  Frontend port ${DEFAULT_FRONTEND_PORT} in use${info ? ` (${info})` : ''}, using alternative...`)
      frontendPort = await findAvailablePort(DEFAULT_FRONTEND_PORT + 1, DEFAULT_FRONTEND_PORT + 100)
    } else {
      frontendPort = DEFAULT_FRONTEND_PORT
    }
  }

  savePorts(backendPort, frontendPort)
  console.log(`  Backend:  ${backendPort}`)
  console.log(`  Frontend: ${frontendPort}`)
  console.log('')

  return { backend: backendPort, frontend: frontendPort }
}

/**
 * Load and validate environment variables
 */
function loadEnv() {
  if (!existsSync(ENV_FILE)) {
    error('.env file not found. Please copy .env.example to .env and configure it.')
  }

  // Bun automatically loads .env files, but let's validate required vars
  const envFile = readFileSync(ENV_FILE, 'utf-8')
  const env: Record<string, string> = {}

  for (const line of envFile.split('\n')) {
    const match = line.match(/^([^=]+)=(.*)$/)
    if (match && !line.trim().startsWith('#')) {
      env[match[1]] = match[2]
    }
  }

  const missing: string[] = []
  if (!env.OPENAI_API_KEY || env.OPENAI_API_KEY === 'your-zai-api-key' || env.OPENAI_API_KEY === 'your-openrouter-api-key') {
    missing.push('OPENAI_API_KEY')
  }
  if (!env.OPENAI_BASE_URL) missing.push('OPENAI_BASE_URL')
  if (!env.OPENAI_MODEL) missing.push('OPENAI_MODEL')

  if (missing.length > 0) {
    error(`Missing or invalid required environment variables:
  - ${missing.join('\n  - ')}

Please configure these variables in your .env file.`)
  }

  log('Env', 'Environment variables validated', colors.green)
}

/**
 * Check and install dependencies if needed
 */
async function checkDependencies(dir: string, name: string) {
  log('Deps', `Checking ${name} dependencies...`)

  const nodeModules = join(dir, 'node_modules')
  const packageJson = join(dir, 'package.json')

  let needsInstall = false

  if (!existsSync(nodeModules)) {
    log('Deps', `${name} node_modules not found, installing...`)
    needsInstall = true
  } else if (existsSync(packageJson)) {
    // Check if package.json is newer than node_modules
    const pkgStat = await Bun.file(packageJson).stat()
    const nmStat = await Bun.file(nodeModules).stat()
    if (pkgStat.mtime > nmStat.mtime) {
      log('Deps', `${name} dependencies outdated, updating...`)
      needsInstall = true
    }
  }

  if (needsInstall) {
    const proc = Bun.spawn(['bun', 'install'], {
      cwd: dir,
      stdout: 'inherit',
      stderr: 'inherit',
    })
    const exitCode = await proc.exited
    if (exitCode !== 0) {
      error(`Failed to install ${name} dependencies`)
    }
    log('Deps', `${name} dependencies installed`, colors.green)
  } else {
    log('Deps', `${name} dependencies OK`, colors.green)
  }
}

/**
 * Start AIMEOW service if enabled
 */
async function startAimeow(backendPort: number): Promise<ProcessPromise | null> {
  const aimeowEnabled = process.env.AIMEOW === 'true'

  if (!aimeowEnabled) {
    return null
  }

  const aimeowDir = join(SCRIPT_DIR, 'bins', 'aimeow')
  const aimeowBinary = process.platform === 'darwin'
    ? join(aimeowDir, 'aimeow.macos')
    : join(aimeowDir, 'aimeow.linux')

  if (!existsSync(aimeowBinary)) {
    log('AIMEOW', 'Binary not found, skipping WhatsApp service', colors.yellow)
    return null
  }

  // Check if binary needs to be rebuilt
  const mainGo = join(aimeowDir, 'main.go')
  const needsBuild = !existsSync(aimeowBinary) ||
    (existsSync(mainGo) && (await Bun.file(mainGo).stat()).mtime > (await Bun.file(aimeowBinary).stat()).mtime)

  if (needsBuild) {
    log('AIMEOW', 'Building...')
    const buildProc = Bun.spawn(['go', 'build', '-ldflags=-s -w', `-o=${aimeowBinary}`, '.'], {
      cwd: aimeowDir,
      env: {
        ...process.env,
        CGO_ENABLED: '1',
      },
      stdout: 'inherit',
      stderr: 'inherit',
    })
    const exitCode = await buildProc.exited
    if (exitCode !== 0) {
      log('AIMEOW', 'Failed to build, skipping WhatsApp service', colors.yellow)
      return null
    }
  }

  // Create AIMEOW data directory
  const aimeowDataDir = join(SCRIPT_DIR, 'data', 'services', 'whatsapp')
  await $`mkdir -p ${join(aimeowDataDir, 'files')}`

  // Start AIMEOW
  log('AIMEOW', 'Starting service...')
  const proc = Bun.spawn([aimeowBinary], {
    cwd: aimeowDataDir,
    env: {
      ...process.env,
      PORT: '7031',
      BASE_URL: 'http://localhost:7031',
      CALLBACK_URL: `http://localhost:${backendPort}/api/whatsapp/webhook`,
      DATA_DIR: '.',
      AIMEOW_LOG_CONFIG: join(SCRIPT_DIR, 'logging.json'),
    },
    stdout: 'inherit',
    stderr: 'inherit',
  })

  return proc
}

/**
 * Wait for a port to start listening
 */
async function waitForPort(port: number, maxWait = 5000): Promise<boolean> {
  const start = Date.now()
  while (Date.now() - start < maxWait) {
    if (await isPortInUse(port)) {
      return true
    }
    await new Promise(resolve => setTimeout(resolve, 100))
  }
  return false
}

/**
 * Start backend with port retry logic
 */
async function startBackend(backendPort: number): Promise<{ proc: typeof Bun.spawn, port: number }> {
  console.log(`Waiting for backend to start on port ${backendPort}...`)

  const proc = Bun.spawn(
    ['bun', '--watch', '--env-file=.env', 'run', 'backend/src/server/index.ts'],
    {
      cwd: SCRIPT_DIR,
      env: {
        ...process.env,
        BACKEND_PORT: backendPort.toString(),
      },
      stdout: 'inherit',
      stderr: 'inherit',
    }
  )

  // Wait for backend to start
  if (!(await waitForPort(backendPort, 5000))) {
    console.log('')
    log('Backend', `Port ${backendPort} in use, finding alternative...`, colors.yellow)
    console.log('Attempting to find an alternative port...')

    // Kill the failed backend process
    proc.kill()
    await proc.exited

    // Find an available port
    const newPort = await findAvailablePort(backendPort + 1, PORT_RANGE_END)
    log('Backend', `Retrying with port ${newPort}...`, colors.green)

    // Update ports file
    savePorts(newPort)

    // Restart with new port
    const newProc = Bun.spawn(
      ['bun', '--watch', '--env-file=.env', 'run', 'backend/src/server/index.ts'],
      {
        cwd: SCRIPT_DIR,
        env: {
          ...process.env,
          BACKEND_PORT: newPort.toString(),
        },
        stdout: 'inherit',
        stderr: 'inherit',
      }
    )

    // Wait and verify
    if (!(await waitForPort(newPort, 5000))) {
      error(`Backend failed to start on port ${newPort} as well.
Please check what's using these ports and try again.`)
    }

    log('Backend', `Started successfully on port ${newPort}`, colors.green)
    return { proc: newProc, port: newPort }
  }

  log('Backend', `Listening on port ${backendPort}`, colors.green)
  return { proc, port: backendPort }
}

/**
 * Main execution
 */
async function main() {
  const processes: (ReturnType<typeof Bun.spawn> | ProcessPromise)[] = []

  // Setup cleanup handler
  const cleanup = async () => {
    console.log('')
    log('Shutdown', 'Shutting down services...', colors.yellow)

    for (const proc of processes) {
      proc.kill()
      await proc.exited
    }

    log('Shutdown', 'All services stopped', colors.green)
    process.exit(0)
  }

  process.on('SIGINT', cleanup)
  process.on('SIGTERM', cleanup)

  // Load and validate environment
  loadEnv()

  // Check dependencies
  await checkDependencies(join(SCRIPT_DIR, 'backend'), 'Backend')
  await checkDependencies(join(SCRIPT_DIR, 'frontend'), 'Frontend')

  // Check current port usage
  await checkPorts()

  // Initialize ports
  const { backend: backendPort, frontend: frontendPort } = await initializePorts()

  // Start AIMEOW if enabled
  const aimeowProc = await startAimeow(backendPort)
  if (aimeowProc) {
    processes.push(aimeowProc)
  }

  // Start services
  console.log('')
  log('Services', 'Starting services...')
  console.log(`  Backend:  port ${backendPort}`)
  console.log(`  Frontend: port ${frontendPort}`)
  console.log('')

  // Start backend with hot-reload
  const { proc: backendProc, port: finalBackendPort } = await startBackend(backendPort)
  processes.push(backendProc)

  // Start frontend
  const frontendProc = Bun.spawn(['bun', 'run', 'dev'], {
    cwd: join(SCRIPT_DIR, 'frontend'),
    env: {
      ...process.env,
      PORT: frontendPort.toString(),
      BACKEND_PORT: finalBackendPort.toString(),
    },
    stdout: 'inherit',
    stderr: 'inherit',
  })
  processes.push(frontendProc)

  log('Services', 'All services started', colors.green)
  console.log('')
  console.log(`  Backend:  http://localhost:${finalBackendPort}`)
  console.log(`  Frontend: http://localhost:${frontendPort}`)
  console.log('')
  console.log('Press Ctrl+C to stop all services')
  console.log('')

  // Wait for all processes
  await Promise.all(processes.map(p => p.exited))
}

main().catch(err => {
  error(err.message)
})
