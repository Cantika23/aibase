#!/bin/bash

# Development script to run backend and frontend concurrently

# Get the script directory
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Port configuration
PORTS_FILE="$SCRIPT_DIR/.dev-ports"
DEFAULT_BACKEND_PORT=5040
DEFAULT_FRONTEND_PORT=5173
PORT_RANGE_START=5041
PORT_RANGE_END=5100

# Function to print error message and exit
error_exit() {
    echo -e "${RED}ERROR: $1${NC}" >&2
    exit 1
}

# Function to print warning message
warn() {
    echo -e "${YELLOW}WARNING: $1${NC}"
}

# Function to print success message
success() {
    echo -e "${GREEN}$1${NC}"
}

# Function to check if a port is in use
is_port_in_use() {
    local port=$1
    # Use multiple methods to check if port is in use
    # Method 1: lsof (most reliable on macOS/Linux)
    if command -v lsof >/dev/null 2>&1; then
        if lsof -Pi :$port -sTCP:LISTEN -t >/dev/null 2>&1 || \
           lsof -Pi :$port -sTCP6:LISTEN -t >/dev/null 2>&1; then
            return 0  # Port is in use
        fi
    fi

    # Method 2: netstat (fallback)
    if command -v netstat >/dev/null 2>&1; then
        if netstat -an -p tcp 2>/dev/null | grep -q "\.$port.*LISTEN"; then
            return 0  # Port is in use
        fi
    fi

    # Method 3: Try to bind to the port (most accurate)
    if command -v nc >/dev/null 2>&1; then
        if nc -z localhost $port 2>/dev/null; then
            return 0  # Port is in use
        fi
    fi

    return 1  # Port is available
}

# Function to find an available port
find_available_port() {
    local start_port=$1
    local end_port=$2

    for ((port=$start_port; port<=$end_port; port++)); do
        if ! is_port_in_use $port; then
            echo $port
            return 0
        fi
    done

    return 1
}

# Function to load saved ports
load_saved_ports() {
    if [ -f "$PORTS_FILE" ]; then
        source "$PORTS_FILE"
        # Verify saved backend port is still available
        if [ -n "$BACKEND_PORT" ] && is_port_in_use $BACKEND_PORT; then
            warn "Saved backend port $BACKEND_PORT is in use, will find new port"
            unset BACKEND_PORT
        fi
        # Frontend port is always reset to default (Vite will auto-adjust)
        unset FRONTEND_PORT
    fi
}

# Function to initialize ports
initialize_ports() {
    # Try to load saved ports first
    load_saved_ports

    # Assign backend port
    if [ -z "$BACKEND_PORT" ]; then
        # No saved port or saved port was in use, find a new one
        if is_port_in_use $DEFAULT_BACKEND_PORT; then
            warn "Default backend port $DEFAULT_BACKEND_PORT is in use"
            BACKEND_PORT=$(find_available_port $PORT_RANGE_START $PORT_RANGE_END)
            if [ $? -ne 0 ]; then
                error_exit "Could not find available port in range $PORT_RANGE_START-$PORT_RANGE_END"
            fi
            success "Found available backend port: $BACKEND_PORT"
        else
            BACKEND_PORT=$DEFAULT_BACKEND_PORT
            success "Using default backend port: $BACKEND_PORT"
        fi
    else
        # We have a saved port, but verify it's actually available
        # (load_saved_ports already checked, but double-check to avoid race conditions)
        if is_port_in_use $BACKEND_PORT; then
            warn "Saved backend port $BACKEND_PORT is now in use, finding alternative..."
            BACKEND_PORT=$(find_available_port $PORT_RANGE_START $PORT_RANGE_END)
            if [ $? -ne 0 ]; then
                error_exit "Could not find available port in range $PORT_RANGE_START-$PORT_RANGE_END"
            fi
            success "Found available backend port: $BACKEND_PORT"
        else
            success "Using saved backend port: $BACKEND_PORT"
        fi
    fi

    # Assign frontend port (Vite will auto-adjust if needed)
    FRONTEND_PORT=$DEFAULT_FRONTEND_PORT
    success "Using default frontend port: $FRONTEND_PORT (Vite may auto-adjust if in use)"

    # Save only the backend port (Vite handles frontend port automatically)
    cat > "$PORTS_FILE" << EOF
# Development ports - auto-generated by dev.sh
# To reset ports, delete this file and run dev.sh again
BACKEND_PORT=$BACKEND_PORT
# Frontend port is managed by Vite and may auto-adjust
EOF

    success "Port configuration saved to $PORTS_FILE"
}

# Array to store background process PIDs
PIDS=()

# Function to kill background processes on exit
cleanup() {
    echo ""
    echo -e "${YELLOW}Shutting down services...${NC}"

    # Kill all tracked background processes
    for pid in "${PIDS[@]}"; do
        if kill -0 $pid 2>/dev/null; then
            # Try graceful shutdown first
            kill $pid 2>/dev/null
        fi
    done

    # Wait up to 5 seconds for processes to terminate gracefully
    local count=0
    while [ $count -lt 5 ]; do
        local all_dead=1
        for pid in "${PIDS[@]}"; do
            if kill -0 $pid 2>/dev/null; then
                all_dead=0
                break
            fi
        done
        if [ $all_dead -eq 1 ]; then
            break
        fi
        sleep 1
        count=$((count + 1))
    done

    # Force kill any remaining processes
    for pid in "${PIDS[@]}"; do
        if kill -0 $pid 2>/dev/null; then
            kill -9 $pid 2>/dev/null
        fi
    done

    success "All services stopped"
    exit 0
}

# Trap SIGINT and SIGTERM to run cleanup
trap cleanup SIGINT SIGTERM

# Check if .env file exists
if [ ! -f "$SCRIPT_DIR/.env" ]; then
    error_exit ".env file not found. Please copy .env.example to .env and configure it."
fi

# Load .env file
set -a
source "$SCRIPT_DIR/.env"
set +a

# Check required environment variables
check_required_env() {
    local missing_vars=()

    if [ -z "$OPENAI_API_KEY" ] || [ "$OPENAI_API_KEY" = "your-zai-api-key" ] || [ "$OPENAI_API_KEY" = "your-openrouter-api-key" ]; then
        missing_vars+=("OPENAI_API_KEY")
    fi

    if [ -z "$OPENAI_BASE_URL" ]; then
        missing_vars+=("OPENAI_BASE_URL")
    fi

    if [ -z "$OPENAI_MODEL" ]; then
        missing_vars+=("OPENAI_MODEL")
    fi

    if [ ${#missing_vars[@]} -gt 0 ]; then
        echo ""
        error_exit "Missing or invalid required environment variables:
  - ${missing_vars[*]}

Please configure these variables in your .env file."
    fi

    success "Environment variables validated"
}

# Check and install dependencies for a directory
check_and_install_dependencies() {
    local dir=$1
    local name=$2

    echo "Checking $name dependencies..."

    local needs_install=0

    # Check if node_modules exists
    if [ ! -d "$dir/node_modules" ]; then
        warn "$name node_modules not found. Installing..."
        needs_install=1
    else
        # Check if package.json has been modified more recently than node_modules
        # This indicates new dependencies may have been added
        if [ "$dir/package.json" -nt "$dir/node_modules" ] 2>/dev/null; then
            warn "$name package.json is newer than node_modules. Updating dependencies..."
            needs_install=1
        fi
    fi

    # Install if needed
    if [ $needs_install -eq 1 ]; then
        cd "$dir"
        bun install
        if [ $? -ne 0 ]; then
            error_exit "Failed to install $name dependencies"
        fi
        cd "$SCRIPT_DIR"
        success "$name dependencies installed"
    else
        success "$name dependencies OK"
    fi
}

# Run checks
check_required_env
check_and_install_dependencies "$SCRIPT_DIR/backend" "Backend"
check_and_install_dependencies "$SCRIPT_DIR/frontend" "Frontend"

# Initialize ports
echo ""
echo -e "${BLUE}=== Port Allocation ===${NC}"
initialize_ports
echo ""

# Check if AIMEOW is enabled
if [ "$AIMEOW" = "true" ]; then
    # Setup aimeow paths
    AIMEOW_DIR="$SCRIPT_DIR/bins/aimeow"
    AIMEOW_BINARY_NAME="aimeow"

    # Determine platform-specific binary name
    if [ "$(uname)" = "Darwin" ]; then
        AIMEOW_BINARY_NAME="aimeow.macos"
    elif [ "$(uname)" = "Linux" ]; then
        AIMEOW_BINARY_NAME="aimeow.linux"
    fi

    AIMEOW_BINARY="$AIMEOW_DIR/$AIMEOW_BINARY_NAME"

    # Check if we need to build (binary doesn't exist or is older than source)
    NEED_BUILD=0
    if [ ! -f "$AIMEOW_BINARY" ]; then
        NEED_BUILD=1
    elif [ "$AIMEOW_DIR/main.go" -nt "$AIMEOW_BINARY" ]; then
        NEED_BUILD=1
    fi

    # Build aimeow if needed
    if [ $NEED_BUILD -eq 1 ]; then
        cd "$AIMEOW_DIR"
        go build -ldflags="-s -w" -o "$AIMEOW_BINARY_NAME" .
        if [ $? -ne 0 ]; then
            warn "Failed to build AIMEOW, skipping WhatsApp service"
        fi
        cd "$SCRIPT_DIR"
    fi

    # Verify aimeow binary exists before trying to start it
    if [ -f "$AIMEOW_BINARY" ]; then
        # Create aimeow data directory
        AIMEOW_DATA_DIR="$SCRIPT_DIR/data/services/whatsapp"
        mkdir -p "$AIMEOW_DATA_DIR/files"

        # Start aimeow service
        cd "$AIMEOW_DATA_DIR"
        PORT=7031 \
        BASE_URL=http://localhost:7031 \
        CALLBACK_URL=http://localhost:$BACKEND_PORT/api/whatsapp/webhook \
        DATA_DIR=. \
        AIMEOW_LOG_CONFIG="$SCRIPT_DIR/logging.json" \
        "$AIMEOW_BINARY" 2>&1 &
        PIDS+=($!)
    else
        warn "AIMEOW binary not found, skipping WhatsApp service"
    fi
fi

echo -e "${BLUE}=== Starting Services ===${NC}"
success "Backend will run on port $BACKEND_PORT"
success "Frontend will run on port $FRONTEND_PORT"
echo ""

# Export BACKEND_PORT for frontend proxy configuration
export BACKEND_PORT

# Start backend with hot-reload
cd "$SCRIPT_DIR"
bun --watch --env-file=.env run backend/src/server/index.ts &
BACKEND_PID=$!
PIDS+=($BACKEND_PID)

# Wait for backend to start and verify it's running
sleep 2

# Check if backend process is still running (might have failed due to port in use)
if ! kill -0 $BACKEND_PID 2>/dev/null; then
    echo ""
    warn "Backend failed to start on port $BACKEND_PORT (port might be in use)"

    # Try to find an available port and restart
    warn "Attempting to find an alternative port..."
    BACKEND_PORT=$(find_available_port $((PORT_RANGE_START + 1)) $PORT_RANGE_END)

    if [ $? -ne 0 ]; then
        error_exit "Could not find available port. Please manually stop the process using port $BACKEND_PORT:
  lsof -ti:$BACKEND_PORT | xargs kill -9"
    fi

    success "Retrying with port $BACKEND_PORT..."

    # Update ports file with new port
    cat > "$PORTS_FILE" << EOF
# Development ports - auto-generated by dev.sh
# To reset ports, delete this file and run dev.sh again
BACKEND_PORT=$BACKEND_PORT
# Frontend port is managed by Vite and may auto-adjust
EOF

    # Export BACKEND_PORT for frontend proxy configuration
    export BACKEND_PORT

    # Restart backend with new port
    bun --watch --env-file=.env run backend/src/server/index.ts &
    BACKEND_PID=$!
    PIDS+=($BACKEND_PID)

    # Wait and verify again
    sleep 2

    if ! kill -0 $BACKEND_PID 2>/dev/null; then
        error_exit "Backend failed to start on port $BACKEND_PORT as well.
Please check what's using these ports and try again."
    fi

    success "Backend started successfully on port $BACKEND_PORT"
fi

# Start frontend with dynamic port and backend proxy
cd "$SCRIPT_DIR/frontend"
PORT=$FRONTEND_PORT BACKEND_PORT=$BACKEND_PORT bun run dev &
PIDS+=($!)

echo -e "${GREEN}âœ“ All services started${NC}"
echo ""
echo -e "${BLUE}Backend:${NC}  http://localhost:$BACKEND_PORT"
echo -e "${BLUE}Frontend:${NC} http://localhost:$FRONTEND_PORT"
echo ""
echo -e "Press ${YELLOW}Ctrl+C${NC} to stop all services"
echo ""

# Wait for all background processes
wait
