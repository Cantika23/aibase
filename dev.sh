#!/bin/bash

# Development script to run backend and frontend concurrently

# Get the script directory
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Port configuration
PORTS_FILE="$SCRIPT_DIR/.dev-ports"
DEFAULT_BACKEND_PORT=5040
DEFAULT_FRONTEND_PORT=5173
PORT_RANGE_START=5041
PORT_RANGE_END=5100

# Function to print error message and exit
error_exit() {
    echo -e "${RED}ERROR: $1${NC}" >&2
    exit 1
}

# Function to print warning message
warn() {
    echo -e "${YELLOW}WARNING: $1${NC}"
}

# Function to print success message
success() {
    echo -e "${GREEN}$1${NC}"
}

# Function to check if a port is in use
is_port_in_use() {
    local port=$1
    # Check for both TCP and TCP6 listeners
    if lsof -Pi :$port -sTCP:LISTEN -t >/dev/null 2>&1 || \
       lsof -Pi :$port -sTCP6:LISTEN -t >/dev/null 2>&1; then
        return 0  # Port is in use
    fi
    return 1  # Port is available
}

# Function to find an available port
find_available_port() {
    local start_port=$1
    local end_port=$2

    for ((port=$start_port; port<=$end_port; port++)); do
        if ! is_port_in_use $port; then
            echo $port
            return 0
        fi
    done

    return 1
}

# Function to load saved ports
load_saved_ports() {
    if [ -f "$PORTS_FILE" ]; then
        source "$PORTS_FILE"
        # Verify saved ports are still available
        if [ -n "$BACKEND_PORT" ] && is_port_in_use $BACKEND_PORT; then
            warn "Saved backend port $BACKEND_PORT is in use, will find new port"
            unset BACKEND_PORT
        fi
        if [ -n "$FRONTEND_PORT" ] && is_port_in_use $FRONTEND_PORT; then
            warn "Saved frontend port $FRONTEND_PORT is in use, will find new port"
            unset FRONTEND_PORT
        fi
    fi
}

# Function to save ports
save_ports() {
    local backend_port=$1
    local frontend_port=$2

    cat > "$PORTS_FILE" << EOF
# Development ports - auto-generated by dev.sh
# To reset ports, delete this file and run dev.sh again
BACKEND_PORT=$backend_port
FRONTEND_PORT=$frontend_port
EOF

    success "Port configuration saved to $PORTS_FILE"
}

# Function to initialize ports
initialize_ports() {
    # Try to load saved ports first
    load_saved_ports

    # Assign backend port
    if [ -z "$BACKEND_PORT" ]; then
        if is_port_in_use $DEFAULT_BACKEND_PORT; then
            warn "Default backend port $DEFAULT_BACKEND_PORT is in use"
            BACKEND_PORT=$(find_available_port $PORT_RANGE_START $PORT_RANGE_END)
            if [ $? -ne 0 ]; then
                error_exit "Could not find available port in range $PORT_RANGE_START-$PORT_RANGE_END"
            fi
            success "Found available backend port: $BACKEND_PORT"
        else
            BACKEND_PORT=$DEFAULT_BACKEND_PORT
            success "Using default backend port: $BACKEND_PORT"
        fi
    else
        success "Using saved backend port: $BACKEND_PORT"
    fi

    # Assign frontend port
    if [ -z "$FRONTEND_PORT" ]; then
        if is_port_in_use $DEFAULT_FRONTEND_PORT; then
            warn "Default frontend port $DEFAULT_FRONTEND_PORT is in use"
            FRONTEND_PORT=$(find_available_port $((PORT_RANGE_END + 1)) $((PORT_RANGE_END + 100)))
            if [ $? -ne 0 ]; then
                error_exit "Could not find available port for frontend"
            fi
            success "Found available frontend port: $FRONTEND_PORT"
        else
            FRONTEND_PORT=$DEFAULT_FRONTEND_PORT
            success "Using default frontend port: $FRONTEND_PORT"
        fi
    else
        success "Using saved frontend port: $FRONTEND_PORT"
    fi

    # Save the port configuration
    save_ports $BACKEND_PORT $FRONTEND_PORT
}

# Function to kill background processes on exit
cleanup() {
    kill $(jobs -p) 2>/dev/null
    wait 2>/dev/null
    exit
}

# Trap SIGINT and SIGTERM to run cleanup
trap cleanup SIGINT SIGTERM

# Check if .env file exists
if [ ! -f "$SCRIPT_DIR/.env" ]; then
    error_exit ".env file not found. Please copy .env.example to .env and configure it."
fi

# Load .env file
set -a
source "$SCRIPT_DIR/.env"
set +a

# Check required environment variables
check_required_env() {
    local missing_vars=()

    if [ -z "$OPENAI_API_KEY" ] || [ "$OPENAI_API_KEY" = "your-zai-api-key" ] || [ "$OPENAI_API_KEY" = "your-openrouter-api-key" ]; then
        missing_vars+=("OPENAI_API_KEY")
    fi

    if [ -z "$OPENAI_BASE_URL" ]; then
        missing_vars+=("OPENAI_BASE_URL")
    fi

    if [ -z "$OPENAI_MODEL" ]; then
        missing_vars+=("OPENAI_MODEL")
    fi

    if [ ${#missing_vars[@]} -gt 0 ]; then
        echo ""
        error_exit "Missing or invalid required environment variables:
  - ${missing_vars[*]}

Please configure these variables in your .env file."
    fi

    success "Environment variables validated"
}

# Check and install dependencies for a directory
check_and_install_dependencies() {
    local dir=$1
    local name=$2

    echo "Checking $name dependencies..."

    if [ ! -d "$dir/node_modules" ]; then
        warn "$name node_modules not found. Installing..."
        cd "$dir"
        bun install
        if [ $? -ne 0 ]; then
            error_exit "Failed to install $name dependencies"
        fi
        cd "$SCRIPT_DIR"
        success "$name dependencies installed"
    else
        success "$name dependencies OK"
    fi
}

# Run checks
check_required_env
check_and_install_dependencies "$SCRIPT_DIR/backend" "Backend"
check_and_install_dependencies "$SCRIPT_DIR/frontend" "Frontend"

# Initialize ports
echo ""
echo -e "${BLUE}=== Port Allocation ===${NC}"
initialize_ports
echo ""

# Check if AIMEOW is enabled
if [ "$AIMEOW" = "true" ]; then
    # Setup aimeow paths
    AIMEOW_DIR="$SCRIPT_DIR/bins/aimeow"
    AIMEOW_BINARY_NAME="aimeow"

    # Determine platform-specific binary name
    if [ "$(uname)" = "Darwin" ]; then
        AIMEOW_BINARY_NAME="aimeow.macos"
    elif [ "$(uname)" = "Linux" ]; then
        AIMEOW_BINARY_NAME="aimeow.linux"
    fi

    AIMEOW_BINARY="$AIMEOW_DIR/$AIMEOW_BINARY_NAME"

    # Check if we need to build (binary doesn't exist or is older than source)
    NEED_BUILD=0
    if [ ! -f "$AIMEOW_BINARY" ]; then
        NEED_BUILD=1
    elif [ "$AIMEOW_DIR/main.go" -nt "$AIMEOW_BINARY" ]; then
        NEED_BUILD=1
    fi

    # Build aimeow if needed
    if [ $NEED_BUILD -eq 1 ]; then
        cd "$AIMEOW_DIR"
        go build -ldflags="-s -w" -o "$AIMEOW_BINARY_NAME" .
        if [ $? -ne 0 ]; then
            exit 1
        fi
    fi

    # Create aimeow data directory
    AIMEOW_DATA_DIR="$SCRIPT_DIR/data/services/whatsapp"
    mkdir -p "$AIMEOW_DATA_DIR/files"

    # Start aimeow service
    cd "$AIMEOW_DATA_DIR"
    PORT=7031 \
    BASE_URL=http://localhost:7031 \
    CALLBACK_URL=http://localhost:$BACKEND_PORT/api/whatsapp/webhook \
    DATA_DIR=. \
    AIMEOW_LOG_CONFIG="$SCRIPT_DIR/logging.json" \
    "$AIMEOW_BINARY" 2>&1 &
fi

echo -e "${BLUE}=== Starting Services ===${NC}"
success "Backend will run on port $BACKEND_PORT"
success "Frontend will run on port $FRONTEND_PORT"
echo ""

# Export BACKEND_PORT for frontend proxy configuration
export BACKEND_PORT

# Start backend with hot-reload
cd "$SCRIPT_DIR"
bun --watch --env-file=.env run backend/src/server/index.ts &

# Wait a moment for backend to start
sleep 2

# Start frontend with dynamic port
cd "$SCRIPT_DIR/frontend"
PORT=$FRONTEND_PORT bun run dev &

# Wait for all background processes
wait
